---
name: orchestrating-tasks
description: 「調べて」「調査して」「実装して」「作って」「開発して」「ビルドして」「テストして」「レビューして」「原因を調べて」「なぜ〜か」「並列で」「同時に」「まとめて」等の作業指示、または複数タスクを含む依頼で自動起動。サブエージェントに委譲してコンテキスト効率化。メインは全体管理とコミュニケーションに集中。
allowed-tools:
  - Task
  - TaskOutput
  - TodoWrite
  - Read
  - Write
  - Bash(date:*)
  - Bash(mkdir:*)
  - Skill
---

# 作業のオーケストレーション

具体的な作業をサブエージェントに委譲し、メインコンテキストをユーザーとのコミュニケーションと全体管理に集中させる。

## 使用タイミング

以下の作業指示があった場合にこのスキルを使用する：
- 調査：「〇〇を調べて」「事例を調査して」「ドキュメントを確認して」
- 実装：「〇〇を実装して」「この機能を作って」
- ビルド：「ビルドして」「ビルドを確認して」
- テスト：「テストを実行して」「テストを書いて」
- レビュー：「このコードをレビューして」「PRを確認して」
- 複合作業：「調査して実装して」「実装してテストまで」

## 基本原則

### コンテキストの役割分担

| コンテキスト | 役割 |
|--------------|------|
| メイン | ユーザーとのコミュニケーション、全体管理、判断、承認 |
| サブエージェント | 具体的な作業の実行、詳細な調査、コード生成 |

### サブエージェントの特徴

- **ultrathinkモード**で深く検討して実行
- **model: opus**で高精度な出力
- 作業完了後に構造化された結果を報告
- メインコンテキストを消費しない

## タスクタイプと並列化

| タイプ | 説明 | 並列化 |
|--------|------|--------|
| `research-web` | Web事例調査、ドキュメント検索 | 可能 |
| `research-code` | 既存コードベースの調査 | 可能 |
| `root-cause-analysis` | エラーや問題の原因分析 | 可能 |
| `implement` | コード実装 | 依存関係による |
| `build` | プロジェクトビルド | 実装後 |
| `test` | テスト実行 | 実装後 |
| `review` | コードレビュー | 実装後 |

### 依存関係

```
research-web        ──┐
research-code       ──┼──> implement ──> build ──> test
root-cause-analysis ──┘                    │
                                           └──> review
```

## ワークフロー

### 1. 作業指示の分析

ユーザーの指示から以下を特定：
- 作業タイプ（調査/実装/ビルド/テスト/レビュー）
- 複数作業の場合は依存関係
- 並列実行の可能性

### 2. 実行計画の提示

**単一作業の場合**：
```
━━━━━━━━━━━━━━━━━━━━━━━━━
📋 実行計画
━━━━━━━━━━━━━━━━━━━━━━━━━

作業: [research-web] React フォームライブラリ調査

サブエージェントに委譲して実行します。
よろしいですか？
━━━━━━━━━━━━━━━━━━━━━━━━━
```

**複数作業の場合**：
```
━━━━━━━━━━━━━━━━━━━━━━━━━
📋 実行計画
━━━━━━━━━━━━━━━━━━━━━━━━━

フェーズ1 (並列実行):
  ├─ [research-web] React フォームライブラリ調査
  └─ [research-code] 既存フォーム実装の確認

フェーズ2 (順次実行):
  └─ [implement] 新フォーム実装

この計画で進めてよろしいですか？
━━━━━━━━━━━━━━━━━━━━━━━━━
```

### 3. サブエージェントの起動

### タスク起動のデフォルト方針

**原則：run_in_background: true をデフォルトとする**

| 状況 | 設定 | 理由 |
|------|------|------|
| 複数タスク | true | 並列実行で高速化 |
| 単一タスク | true | 他作業の余地を残す |
| 結果が即座に必要 | false | 待機が必須の場合のみ |

**メリット**：
- メインコンテキストが他の作業を継続可能
- 複数タスクの並列実行で時間短縮
- ユーザーへの応答性向上

**結果取得**：
- TaskOutput(task_id, block: true) で結果を待機
- 複数タスクの場合は並列で TaskOutput を呼び出し

**基本呼び出し形式**：

```
Task(
  subagent_type: "general-purpose",
  model: "opus",
  prompt: "[ULTRATHINK MODE - 深く検討して実行してください]

タスク: <タスク説明>

## 目的
<具体的な目標>

## 実行内容
<詳細な指示>

## 期待する成果物
- <成果物1>
- <成果物2>

## 報告フォーマット
### サマリー
<3-5行の要約>

### 詳細
<詳細な内容>

### 推奨事項
<次のステップへの提案>

### 参照情報
<URL、ファイルパス等>
",
  description: "<短いタスク説明>",
  run_in_background: true
)
```

**並列実行時**は単一メッセージで複数起動：
```
Task(タスク1, run_in_background: true)
Task(タスク2, run_in_background: true)
```

### 4. 結果の収集

**バックグラウンド実行の場合**：

```
# 進捗確認（ノンブロッキング）
AgentOutputTool(agentId: "<id>", block: false)

# 結果取得（ブロッキング）
AgentOutputTool(agentId: "<id>", block: true)
```

### 5. 結果報告とネクストアクション

**完了報告**：
```
━━━━━━━━━━━━━━━━━━━━━━━━━
📊 完了報告
━━━━━━━━━━━━━━━━━━━━━━━━━

## サマリー
<サブエージェントからの要約>

## 主要な発見/成果
1. <ポイント1>
2. <ポイント2>
3. <ポイント3>

## 次のアクション
- [ ] <推奨アクション1>
- [ ] <推奨アクション2>
━━━━━━━━━━━━━━━━━━━━━━━━━
```

## タスクタイプ別プロンプト

**building-task-prompts Skill** を使用してプロンプトを生成する。
詳細なテンプレートは `reference/subagent-prompts.md` も参照可能。

### クイックリファレンス

| タスクタイプ | 主要なプロンプト要素 |
|--------------|---------------------|
| research-web | 検索キーワード、評価基準、サマリー形式 |
| research-code | 対象パターン、ファイルスコープ、分析深度 |
| root-cause-analysis | エラー内容、再現手順、仮説、調査範囲 |
| implement | 要件、制約、既存パターン |
| build | ビルドコマンド、期待出力、エラー処理 |
| test | テストスコープ、カバレッジ要件、失敗時処理 |
| review | レビュー基準、重点領域、出力形式 |

## エラーハンドリング

### サブエージェントタイムアウト

```
⚠️ サブエージェントタイムアウト

エージェントID: <id>
タスク: <説明>
経過時間: XX分

対応オプション:
A. 継続して待機
B. タスクをキャンセルして手動対応
C. より小さいタスクに分割して再実行

どのように進めますか？
```

### サブエージェント失敗

```
⚠️ サブエージェント失敗

エージェントID: <id>
タスク: <説明>
エラー: <エラーメッセージ>

対応オプション:
A. 手動で対応して継続
B. 代替アプローチを検討
C. タスクを中止

どのように進めますか？
```

### 依存関係違反

```
⚠️ 依存関係の問題

「<タスクB>」は「<タスクA>」の完了を必要とします。

理由: <説明>

対応オプション:
A. 正しい順序で実行
B. 依存関係を無視して実行（非推奨）
C. 実行計画を再検討

どのように進めますか？
```

### 部分的成功（複数タスク時）

```
⚠️ 一部タスクが失敗

成功: X/Y タスク
失敗: <失敗タスクリスト>

対応オプション:
A. 成功したタスクの結果で継続
B. 失敗タスクを再試行
C. 全体を中止

どのように進めますか？
```

## ベストプラクティス

### タスク粒度
- 粗すぎる：サブエージェントが過負荷
- 細かすぎる：オーバーヘッドが利点を上回る
- 最適：5〜30分程度のタスク

### 並列実行
- 最大3〜5個の同時サブエージェント
- 関連する調査をグループ化
- 独立したタスクを優先的に並列化

### 並列化判断基準

以下の基準で並列実行を判断する：

**並列実行可能な組み合わせ**：
| 組み合わせ | 理由 |
|------------|------|
| `research-web` + `research-code` | コードベース調査と外部仕様調査は独立 |
| `research-code` + `research-code` | 異なる観点なら並列可能（例：既存実装パターン + エラーハンドリング） |
| `research-web` + `research-web` | 異なるトピックなら並列可能（例：ライブラリ調査 + ベストプラクティス） |
| `root-cause-analysis` + `research-code` | 原因分析と関連コード調査は並列可能 |

**順次実行が必要な組み合わせ**：
| 組み合わせ | 理由 |
|------------|------|
| 調査 → 実装 | 調査結果に基づいて実装方針が決まる |
| 実装 → ビルド | 実装完了後にビルド |
| 実装/ビルド → テスト | 動作するコードが必要 |
| 同一ファイルへの実装 | 競合を避けるため順次実行 |

**判断フロー**：
1. タスク間でデータ依存があるか？ → あれば順次
2. 同一リソース（ファイル）を変更するか？ → するなら順次
3. 上記に該当しない → 並列実行可能

### コンテキスト効率
- サブエージェントには必要なコンテキストのみを渡す
- 結果は要約してメインに戻す
- 大きなコードブロックを重複させない

### Ultrathinkモードの使用
- サブエージェントプロンプトには常に`[ULTRATHINK MODE]`を含める
- 必要な分析の深さを指定
- 構造化された出力を要求

## 注意事項

- このスキルは**オーケストレーション**を行い、直接実装はしない
- サブエージェントがultrathinkモードで実際の作業を行う
- 実行開始前にユーザー承認が必要
- 結果報告には必ずネクストアクションを含める
- メインコンテキストは判断とコミュニケーションに集中

## 関連スキル

- **building-task-prompts**: サブエージェント用プロンプト生成（本スキルから利用）
- **task-driven-development**: チェックポイント付きの仕様駆動実装
- **spec-workflow-orchestrator**: 完全な仕様駆動ワークフロー管理
