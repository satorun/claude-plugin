# ベストプラクティス

## タスク粒度

- **粗すぎる**：サブエージェントが過負荷
- **細かすぎる**：オーバーヘッドが利点を上回る
- **最適**：5〜30分程度のタスク

## 並列実行

- 最大3〜5個の同時サブエージェント
- 関連する調査をグループ化
- 独立したタスクを優先的に並列化

## 並列化判断基準

以下の基準で並列実行を判断する：

### 並列実行可能な組み合わせ

| 組み合わせ | 理由 |
|------------|------|
| `research-web` + `research-code` | コードベース調査と外部仕様調査は独立 |
| `research-code` + `research-code` | 異なる観点なら並列可能（例：既存実装パターン + エラーハンドリング） |
| `research-web` + `research-web` | 異なるトピックなら並列可能（例：ライブラリ調査 + ベストプラクティス） |
| `root-cause-analysis` + `research-code` | 原因分析と関連コード調査は並列可能 |

### 順次実行が必要な組み合わせ

| 組み合わせ | 理由 |
|------------|------|
| 調査 → 実装 | 調査結果に基づいて実装方針が決まる |
| 実装 → ビルド | 実装完了後にビルド |
| 実装/ビルド → テスト | 動作するコードが必要 |
| 同一ファイルへの実装 | 競合を避けるため順次実行 |

### 判断フロー

1. タスク間でデータ依存があるか？ → あれば順次
2. 同一リソース（ファイル）を変更するか？ → するなら順次
3. 上記に該当しない → 並列実行可能

## コンテキスト効率

- サブエージェントには必要なコンテキストのみを渡す
- 結果は要約してメインに戻す
- 大きなコードブロックを重複させない

## Ultrathinkモードの使用

- サブエージェントプロンプトには常に`[ULTRATHINK MODE]`を含める
- 必要な分析の深さを指定
- 構造化された出力を要求
